buildscript {
    repositories {
        // mavenLocal()
    }

    dependencies {
        classpath fileTree("../build/libs")
    }
}



import com.github.dnault.xmlpatch.XmlPatchFilter
import com.github.dnault.xmlpatch.batch.AssembledPatch
import com.github.dnault.xmlpatch.batch.BatchXmlPatchFilter
import com.github.dnault.xmlpatch.gradle.PatchXml
import org.gradle.api.internal.AbstractTask

//import com.github.dnault.xmlpatch.gradle.BatchPatchXml
apply plugin: 'java'

//tasks.withType(BatchPatchXml) {
//  failOnMissingSource = false
//}

task patchPlease(type: PatchXml) {
    from "source/foo2.xml"
    into "build/patched"
    patch file("patch.xml")
    eachFile {
        println it.sourcePath
        //     filter(XmlPatchFilter, patch: "patch.xml")
    }
}
/*
task batch(type: BatchPatchXml) {
from "source"
into "build/patched"
patch file("batch-patch.xml")

failOnMissingSource = true

//failOnMissingPatch = false
// failOnMissingSource = false
}
  */

def augmentWithXmlPatch(CopySpec copySpec, File patchFile) {

    boolean failOnMissingSourcePath = false
    boolean failOnMissingPatch = true

    if (failOnMissingPatch && !patchFile.exists()) {
        throw new RuntimeException("Patch file does not exist: ${patchFile.absolutePath}")
    }

    println failOnMissingSourcePath
    println failOnMissingPatch

    configure(copySpec) {
        def assembledPatch = new AssembledPatch(patchFile);

        eachFile {
            filter([patch: assembledPatch, sourcePath: it.sourcePath], BatchXmlPatchFilter)
        }

        if (copySpec instanceof AbstractTask) {
            def seenSourcePaths = [] as Set
            def missingSourcePaths = [] as Set

            eachFile {
                seenSourcePaths += [it.sourcePath]
            }

            inputs.files assembledPatch.patchFiles

            doLast {
                missingSourcePaths = assembledPatch.sourcePaths - seenSourcePaths
                if (!missingSourcePaths.isEmpty()) {
                    String message = "XML patch ${patchFile} references missing source paths: " + missingSourcePaths

                    if (failOnMissingSourcePath) {
                        throw new RuntimeException(message);
                    } else {
                        logger.info(message)
                    }
                }
            }

            // store some properties in the task to help diagnose issues
            //ext.xmlPatch = new XmlPatchExtraProperties()
            //xmlPatch.assembledPatch = assembledPatch
            //xmlPatch.seenSourcePaths = [] as Set
            //xmlPatch.missingSourcePaths = [] as Set
        }
    }
}


def mySpec = copySpec {
    from "foo"
    into "bar"
}

augmentWithXmlPatch processResources, file("resources-patch.xml")//failOnMissingSourcePath: false, failOnMissingPatch: false)
//configureXmlPatch mySpec , file("resources-patch.xml")

//println tasks.processResources.xmlPatch.assembledPatch.patchFiles

/*
tasks.processResources {
inputs.files multiPatch.patchFiles
eachFile {
println it.sourcePath
filter([patch: multiPatch, sourcePath: it.sourcePath], BatchXmlPatchFilter)

}
//filter(XmlPatchFilter, patch: "patch.xml")
}
  */

//println(multiPatch)

task patch(type: Copy) {
    inputs.file "patch.xml"
    //filter(XmlPatchFilter, patch: "patch.xml")

    from "source"
    into "build/patched"
    rename { "dest.xml" }

    eachFile {
        println it.sourcePath
        filter(XmlPatchFilter, patch: "patch.xml")
    }
}

/*
class PatchXml extends Copy {
    @InputFile File patch;

    @Override
    protected void copy() {
        filter(XmlPatchFilter, patch: patch.getAbsolutePath())

        super.copy()
    }
} */